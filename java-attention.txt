String与String值相等比较用equals()方法，char与char值相等比较用”==”进行比较。
静态方法是不能使用非静态方法和非静态变量的.

静态方法可以通过所在类直接调用而不需要实例化对象，非静态成员变量则是一个对象的属性

它只有在有实例化对象时才存在的，所以在静态方法中是不可以调用静态变量的！

extend:继承是is-a 关系,a继承b,这表明a is a b.

子类和父类：
	1）如果子类覆盖了父类的一个方法，那么在动态方法选择时就会选择子类的方法。也就是说，方法选择是取决于动态类型的。

	2）类型检测：
		编译时期，编译器检查实例的静态类型，如果实例调用一个静态类型没有的方法，那么他将无法通过编译。
		举例：a是A的一个子类，在a中自定义了一个方法m，则：
		A x = new a；
		a.m；
		第二行代码将无法通过编译，编译时编译器首先检查静态类型方法，因为m方法并不存在于A中，所以无法通过，尽管
xde动态类型是a。
	3）实例的动态类型不会是静态类型的父类，如果是，那么将无法通过编译。以上述例子证明：
		a x = new A；这是无法通过编译的；
		或者
		A x = new a；
		a y = new x；
		这依然无法通过编译，因为在编译y的时刻，y的静态类型是a，x的静态类型是A，这是不允许的。 
